interface types {
    /// Parse failed
    enum parse-error {
        /// The input string is empty
        empty,
        /// The input string is not a valid number
        invalid,
    }

    /// The basic unit of big numbers, which can be shared in big-integer, big-fraction, big-complex and other composite structures.
    ///
    /// Unsigned integers are immutable shared objects. Therefore, some memory allocation can be avoided when creating operations such as inverse numbers, absolute values, fractions, etc.
    ///
    /// Equal big integers do not necessarily have the same resource ID. As long as every bit that makes up the large integer is equal, the two large integers are equal.
    resource unsigned-integer {
        from-u32: static func(value: u32) -> unsigned-integer;
        from-u64: static func(value: u64) -> unsigned-integer;

        add: func(other: borrow<unsigned-integer>) -> unsigned-integer;
        sub: func(other: borrow<unsigned-integer>) -> unsigned-integer;
        sub-saturating: func(other: borrow<unsigned-integer>) -> unsigned-integer;
        sub-checked: func(other: borrow<unsigned-integer>) -> option<unsigned-integer>;

        mul: func(other: borrow<unsigned-integer>) -> unsigned-integer;
        div: func(other: borrow<unsigned-integer>) -> unsigned-integer;

        as-f32: func() -> float32;
        as-f64: func() -> float64;

        parse: static func(text: string, radix: u32) -> result<unsigned-integer, parse-error>;
        to-radix-string: func(radix: u32) -> string;
    }
    enum sign {
        /// Neither positive nor negative, such as zero
        no-sign,
        /// This is a positive number greater than zero
        positive,
        /// This is a negative number less than zero
        negative,
    }
    record integer {
        sign: sign,
        digits: borrow<unsigned-integer>,
    }
    /// The numerator and denominator must be the simplest fraction, that is, gcd(numerator, denominator) = 1.
    ///
    /// ## Zero
    ///
    /// The canonical form is fraction { sign = no-sign, numerator = 0, denominator = 1 }.
    ///
    /// If the sign is no-sign, then the number is considered to represent zero and the numerator and denominator are no longer checked.
    record fraction {
        sign: sign,
        numerator: borrow<unsigned-integer>,
        denominator: borrow<unsigned-integer>,
    }
}
